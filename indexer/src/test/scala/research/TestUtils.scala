package research

import java.io.ByteArrayOutputStream
import java.io.PrintWriter
import java.io.StringWriter
import java.net.URI

import scala.tools.nsc.Settings
import scala.tools.nsc.interactive.Global
import scala.tools.nsc.reporters.ConsoleReporter
import scala.util.Failure
import scala.util.Success

import org.junit.ComparisonFailure

import converter.ScalacConverter
import indexer.hierarchy.Hierarchy
import indexer.util.LoggerConfig
import javax.tools.FileObject
import javax.tools.JavaFileManager
import javax.tools.JavaFileObject
import javax.tools.SimpleJavaFileObject
import javax.tools.StandardJavaFileManager
import javax.tools.ToolProvider
import research.converter.ClassfileConverter

object TestUtils extends AnyRef with LoggerConfig {

  var debugTests: Boolean = true

  final implicit class Assert_===[A](private val actual: A) extends AnyVal {
    def ===(expected: A): Unit = {
      if (actual != expected) {
        (actual, expected) match {
          case (actual: Seq[_], expected: Seq[_]) ⇒
            val as = actual.map(_.toString).sorted.mkString("\n")
            val es = expected.map(_.toString).sorted.mkString("\n")
            throw new ComparisonFailure("", es, as)
          case (actual: Set[_], expected: Set[_]) ⇒
            val as = actual.toSeq.map(_.toString).sorted.mkString("\n")
            val es = expected.toSeq.map(_.toString).sorted.mkString("\n")
            throw new ComparisonFailure("", es, as)
          case _ ⇒
            throw new ComparisonFailure("", expected.toString, actual.toString)
        }
      }
    }
  }

  /** `data` is a sequence of `(filename, src)` */
  def convertToHierarchy(data: (String, String)*): Seq[(String, Seq[Hierarchy])] = {
    val s = new Settings
    val writer = new StringWriter
    val reporter = new ConsoleReporter(s, Console.in, new PrintWriter(writer, /* autoFlush */true))
    val g = new Global(s, reporter)

    def withResponse[A](f: g.Response[A] ⇒ Unit) = {
      val r = new g.Response[A]
      f(r)
      r
    }

    val sfs = data map {
      case (filename, src) ⇒
        val sf = g.newSourceFile(src, filename)
        filename → sf
    }
    withResponse[Unit] { g.askReload(sfs.map(_._2).toList, _) }.get
    sfs.filter(!_._1.endsWith(".java")) map {
      case (filename, sf) ⇒
        val tree = withResponse[g.Tree](g.askLoadedTyped(sf, keepLoaded = true, _)).get.left.get

        if (reporter.hasErrors || reporter.hasWarnings)
          throw new IllegalStateException(s"Errors occurred during compilation of file `$filename`:\n$writer")

        val res = g ask { () ⇒ new ScalacConverter[g.type](g).convert(tree) }

        res match {
          case Success(res) ⇒
            filename → res
          case Failure(f) ⇒
            throw f
        }
    }
  }

  /**
   * Represents an in memory Java file by its name and its source code.
   */
  private final class VirtualJavaFile(name: String, code: String)
      extends SimpleJavaFileObject(URI.create(s"string:///$name"), JavaFileObject.Kind.SOURCE) {
    override def getCharContent(ignoreEncodingErrors: Boolean): CharSequence = code
  }

  /**
   * Wraps a `StandardJavaFileManager` in order to allow us to access the
   * bytecode that is generated by the Java compiler.
   */
  private final class VirtualJavaFileManager(underlying: StandardJavaFileManager) extends JavaFileManager {
    import JavaFileManager._
    import JavaFileObject._

    private var bs = Map[String, ByteArrayOutputStream]()

    def buffers = bs.map { case (k, v) ⇒ k → v.toByteArray() }.toList

    override def getJavaFileForOutput(location: Location, className: String, kind: Kind, sibling: FileObject): JavaFileObject = {
      new SimpleJavaFileObject(URI.create(className), kind) {
        override def openOutputStream = {
          val s = new ByteArrayOutputStream
          bs += className → s
          s
        }
      }
    }

    // the following methods forward to the default implementation
    override def getJavaFileForInput(location: Location, className: String, kind: Kind): JavaFileObject = underlying.getJavaFileForInput(location, className, kind)
    override def getClassLoader(location: Location): ClassLoader = underlying.getClassLoader(location)
    override def close(): Unit = underlying.close()
    override def flush(): Unit = underlying.flush()
    override def getFileForInput(x$1: Location, x$2: String, x$3: String): FileObject = underlying.getFileForInput(x$1, x$2, x$3)
    override def getFileForOutput(x$1: Location, x$2: String, x$3: String, x$4: FileObject): FileObject = underlying.getFileForOutput(x$1, x$2, x$3, x$4)
    override def handleOption(current: String, remaining: java.util.Iterator[String]): Boolean = underlying.handleOption(current, remaining)
    override def hasLocation(x$1: Location): Boolean = underlying.hasLocation(x$1)
    override def inferBinaryName(x$1: Location, x$2: JavaFileObject): String = underlying.inferBinaryName(x$1, x$2)
    override def isSameFile(a: FileObject, b: FileObject): Boolean = underlying.isSameFile(a, b)
    override def isSupportedOption(option: String): Int = underlying.isSupportedOption(option)
    override def list(x$1: Location, x$2: String, x$3: java.util.Set[Kind], x$4: Boolean): java.lang.Iterable[JavaFileObject] = underlying.list(x$1, x$2, x$3, x$4)
  }

  def bytecodeToHierarchy(data: (String, String)*): Seq[(String, Seq[Hierarchy])] = {
    val c = ToolProvider.getSystemJavaCompiler
    val vfm = new VirtualJavaFileManager(c.getStandardFileManager(null, null, null))

    data flatMap {
      case (filename, src) ⇒
        require(filename.endsWith(".java"), "Only Java files are currently supported")
        val s = new ByteArrayOutputStream
        val pw = new PrintWriter(s)

        c.getTask(
            pw, vfm, null,
            /* options */ java.util.Arrays.asList("-parameters"),
            null,
            /* compilationUnits */ java.util.Arrays.asList(new VirtualJavaFile(filename, src))
        ).call()

        val errorMsgs = new String(s.toByteArray(), "UTF-8")
        if (errorMsgs.nonEmpty)
          throw new IllegalStateException(s"Errors occurred during compilation of file `$filename`:\n$errorMsgs")

        vfm.buffers.map {
          case (_, bytecode) ⇒
            val res = new ClassfileConverter().convert(bytecode)
            res match {
              case Success(res) ⇒
                filename → res
              case Failure(f) ⇒
                throw f
            }
        }
    }
  }
}
